using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;

// These examples show:
// - How a foreach loop can be expressed with a while loop to show the usage of iterators in C#.
namespace ForeachExample
{
    public class Program
    {
        private static void ForEachDissected()
        {
            /*-----------------------------------------------------------------------------------*/
            // How Iterators (IEnumerable/IEnumerator) are used in foreach Loops:

            // Let's inspect this code snippet:
            ArrayList theList = new ArrayList(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
            // Iterate over the list with foreach:
            foreach (object item in theList)// The item is of type object to avoid unboxing to int.
            {
                // Though item is of type object, no further boxing of item to object is required
                // to call Console.WriteLine():
                Debug.WriteLine(string.Format("Next i: {0}", item));
            }


            #region Something like the following Code is generated by the C# Compiler:
            // Iterators are really used this way in a forach loop:
            // (1) The entity being iterated (e.g. a Collection) has to implement the interface
            // IEnumerable/<T>, then such an entity is called _sequence_. IEnumerable's method
            // GetEnumerator() will be called first. The object returned by GetEnumerator() is
            // called _iterator_.  I.e. multiple iterators can correspond to a sequence. In
            // database terms: IEnumerable/<T> is similar to a table and IEnumerator/<T> is similar
            // to a cursor.
            IEnumerator items = theList.GetEnumerator();
            try
            {
                // (2) The IEnumerator class has to implement MoveNext() that moves the iterator to
                // the next state and returns the information, whether there are more items to
                // come.
                while (items.MoveNext())
                {
                    // (3) The IEnumerator class has to implement the property Current.
                    // Possibly the Current item must be cast or unboxed.
                    Debug.WriteLine(string.Format("Next i: {0}", items.Current));
                }
            }
            finally
            {
                // (4) Since C#1.2: Dispose of the iterator, if the iterator supports this (i.e.
                // implements the interface IDisposable).
                IDisposable disposable = items as IDisposable;
                if (null != disposable)
                {
                    disposable.Dispose();
                }
                // Not shown here:
                // If the entity being iterated (e.g. a Collection) is generic, the generic
                // interface IEnumerable<T> will be implemented by that entity as well and
                // IEnumerator<T> will be returned by IEnumerable<T>.GetEnumerator().
                // IEnumerator<T> implements the interface IDisposable, so no further downcast is
                // required and Dispose() can be called directly on the iterator.
            }

            // Sidebar: Additionally the interface IEnumerator/<T> provides the method Reset().
            // This method must only be provided for COM interoperability. It needs not to be
            // implemented; instead, the implementer can simply throw a NotSupportedException.
            #endregion
        }


        public static void Main(string[] args)
        {
            /*-----------------------------------------------------------------------------------*/
            // Calling the Example Methods:

            ForEachDissected();
        }
    }
}